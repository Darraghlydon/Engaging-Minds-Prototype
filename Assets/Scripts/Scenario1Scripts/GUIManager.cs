using TMPro;
using UnityEditor.PackageManager;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.LowLevel;
using UnityEngine.SceneManagement;
using static UnityEngine.EventSystems.StandaloneInputModule;

public enum UIState
{
    Default,
    Start,
    Pause,
    ControlMethodSelection,
    Credits
}

public class GUIManager : MonoBehaviour
{
    [SerializeField] private GameObject _pauseScreen;
    [SerializeField] private GameObject _startScreen;
    [SerializeField] private GameObject _controlsScreen;
    [SerializeField] private string _mainMenuSceneName;
    [SerializeField] private GameObject _defaultButtonStart;
    [SerializeField] private GameObject _defaultButtonPause;
    [SerializeField] private GameObject _defaultButtonControls;
    //[SerializeField] private TMP_Text _infoText;
    private PlayerActionsAutoGenerated _playerActions;
    private UIState _currentState;
    private UIState _storedUIState = UIState.Default;
    private GameInputMode _previousMode;


    public void Awake()
    {
        //_playerActions = new PlayerActionsAutoGenerated();
    }


    public void Start()
    {
        CloseOpenScreens();
        _currentState = UIState.Start;
        SwitchState(_currentState);
        InputManager.Instance.SwitchToUI();
        _previousMode = GameInputMode.MainGame;
        
        InputManager.Instance.Actions.MainGame.Menu.performed += DisplayPauseScreen;
        InputManager.Instance.Actions.ReactionGame.Menu.performed += DisplayPauseScreen;
    }


    void OnEnable()
    {
        SetupNavigationForWebGL();
        
    }

    void OnDestroy()
    {

        if (InputManager.Instance != null)
        {
            InputManager.Instance.Actions.MainGame.Menu.performed -= DisplayPauseScreen;
            InputManager.Instance.Actions.ReactionGame.Menu.performed -= DisplayPauseScreen;
        }

        //Events.SubtitlesSkip.Unsubscribe(SubtitlesSkip);
        //Events.SubtitlesStop.Unsubscribe(OnSubtitlesStopped); // FIXED
    }

    void SwitchState(UIState newState)
    {
        switch (newState)
        {

            case UIState.Pause:
                Pause();
                _pauseScreen.SetActive(true);
                EventSystem.current.SetSelectedGameObject(_defaultButtonPause);
                break;
            case UIState.ControlMethodSelection:
                _storedUIState = _currentState;
                Pause();
                _controlsScreen.SetActive(true);
                EventSystem.current.SetSelectedGameObject(_defaultButtonControls);
                break;

            case UIState.Start:
                InputManager.Instance.SwitchToUI();
                Pause();
                _startScreen.SetActive(true);
                EventSystem.current.SetSelectedGameObject(_defaultButtonStart);
                break;


            default:

                Unpause();
                break;
        }
        _currentState = newState;
    }

    void Pause()
    {
        Time.timeScale = 0;
        AudioListener.pause = true;
        
        Debug.Log(_previousMode);
        InputManager.Instance.SwitchToUI();
        Events.Pause.Publish();
    }

    void Unpause()
    {
        Time.timeScale = 1;
        AudioListener.pause = false;
        switch (_previousMode)
        {
            case GameInputMode.MainGame:
                InputManager.Instance.SwitchToMainGame();
                break;

            case GameInputMode.ReactionGame:
                InputManager.Instance.SwitchToReactionGame();
                break;
        }
        Events.Unpause.Publish();
    }

    public void DisplayPauseScreen(InputAction.CallbackContext context)
    {
        DisplayPauseScreen();
    }

    public void DisplayPauseScreen()
    {
        _previousMode = InputManager.Instance.CurrentMode;
        if (CheckForOpenScreens() == false)
        {
            CloseOpenScreens();
            SwitchState(UIState.Pause);
        }
    }

    public void CloseOpenScreens()
    {
        _startScreen.SetActive(false);
        _pauseScreen.SetActive(false);
        _controlsScreen.SetActive(false);

        if (_storedUIState != UIState.Default)
        {
            SwitchState(_storedUIState);
            _storedUIState = UIState.Default;
        }
    }

    public void DisplayControlMethodScreen()
    {
        CloseOpenScreens();
        SwitchState(UIState.ControlMethodSelection);
    }

    public void DisplayCreditsScreen()
    {
        CloseOpenScreens();
        SwitchState(UIState.Credits);
    }

    private bool CheckForOpenScreens()
    {
        if (_startScreen.activeSelf == true || _pauseScreen.activeSelf == true || _controlsScreen.activeSelf == true)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    public void ResumeGame()
    {
        //DisableMouse();
        CloseOpenScreens();
        Unpause();
        

    }

    public void LoadMainMenu()
    {
        SceneManager.LoadScene(_mainMenuSceneName);
    }

    private void SetupNavigationForWebGL()
    {
        // This is required to rectify a bug in WebGL deployments where up and down does not work on GUI screens
        // Note: Not currently working in this build.  Believe because we are still using old input.  Further research required.
        InputBinding binding = new InputBinding()
        {
            path = "<Gamepad>/leftStick",
            processors = "webglnavigation"
        };

        //defaultNavigateInputActionReference.action.AddBinding(binding);
    }

}
