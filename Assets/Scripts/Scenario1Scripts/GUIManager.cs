using TMPro;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.InputSystem;
using UnityEngine.SceneManagement;

public enum UIState
{
    Default,
    Start,
    Pause,
    ControlMethodSelection,
    Credits,
    MaxStress,
    BreathingGame
}

public class GUIManager : MonoBehaviour
{
    [Header("Screens")]
    [SerializeField] private GameObject _pauseScreen;
    [SerializeField] private GameObject _defaultButtonPause;
    [SerializeField] private GameObject _startScreen;
    [SerializeField] private GameObject _defaultButtonStart;
    [SerializeField] private GameObject _controlsScreen;
    [SerializeField] private GameObject _defaultButtonControls;
    [SerializeField] private GameObject _maxStressScreen;
    [SerializeField] private GameObject _defaultButtonMaxStress;
    [SerializeField] private GameObject _breathingGameScreen;
    [Header("Settings")]
    [SerializeField] private string _mainMenuSceneName;

    //[SerializeField] private TMP_Text _infoText;
    private PlayerActionsAutoGenerated _playerActions;
    private UIState _currentState;
    private UIState _storedUIState = UIState.Default;
    private GameInputMode _previousMode;


    public void Awake()
    {
        //_playerActions = new PlayerActionsAutoGenerated();
    }


    public void Start()
    {
        CloseAllScreens();
        _currentState = UIState.Start;
        SwitchState(_currentState);
        InputManager.Instance.SwitchToUI();
        _previousMode = GameInputMode.MainGame;
        
        InputManager.Instance.Actions.MainGame.Menu.performed += DisplayPauseScreen;
        InputManager.Instance.Actions.ReactionGame.Menu.performed += DisplayPauseScreen;
        InputManager.Instance.Actions.BreathingGame.Menu.performed += DisplayPauseScreen;
    }


    void OnEnable()
    {
        SetupNavigationForWebGL();
        Events.MaxStressReached.Subscribe(OnMaxStressReached);
        Events.DisplayBreathingGame.Unsubscribe(DisplayBreathingGame);
    }

    void OnDisable()
    {
        Events.MaxStressReached.Unsubscribe(OnMaxStressReached);
        Events.DisplayBreathingGame.Unsubscribe(DisplayBreathingGame);

    }

    void OnDestroy()
    {

        if (InputManager.Instance != null)
        {
            InputManager.Instance.Actions.MainGame.Menu.performed -= DisplayPauseScreen;
            InputManager.Instance.Actions.ReactionGame.Menu.performed -= DisplayPauseScreen;
            InputManager.Instance.Actions.BreathingGame.Menu.performed -= DisplayPauseScreen;
        }

    }

    void SwitchState(UIState newState)
    {
        switch (newState)
        {

            case UIState.Pause:
                InputManager.Instance.SwitchToUI();
                Pause();
                _pauseScreen.SetActive(true);
                EventSystem.current.SetSelectedGameObject(_defaultButtonPause);
                break;
            case UIState.ControlMethodSelection:
                _storedUIState = _currentState;
                //Pause();
                _controlsScreen.SetActive(true);
                EventSystem.current.SetSelectedGameObject(_defaultButtonControls);
                break;

            case UIState.Start:
                InputManager.Instance.SwitchToUI();
                Pause();
                _startScreen.SetActive(true);
                EventSystem.current.SetSelectedGameObject(_defaultButtonStart);
                break;
            case UIState.MaxStress:
                InputManager.Instance.SwitchToUI();
                Pause();
                _maxStressScreen.SetActive(true);
                EventSystem.current.SetSelectedGameObject(_defaultButtonMaxStress);
                break;
            case UIState.BreathingGame:
                InputManager.Instance.SwitchToBreathingGame();
                Pause();
                _breathingGameScreen.SetActive(true);
                break;



            default:

                Unpause();
                break;
        }
        _currentState = newState;
    }

    void Pause()
    {
        Time.timeScale = 0;      
        Debug.Log(_previousMode);
        Events.Pause.Publish();
    }

    void Unpause()
    {
        Debug.Log("Previous Mode: " + _previousMode);
        switch (_previousMode)
        {
            case GameInputMode.MainGame:
                InputManager.Instance.SwitchToMainGame();
                Time.timeScale = 1;
                break;

            case GameInputMode.ReactionGame:
                InputManager.Instance.SwitchToReactionGame();
                break;

            case GameInputMode.BreathingGame:
                InputManager.Instance.SwitchToBreathingGame();
                break;
        }
        Events.Unpause.Publish();
    }

    public void DisplayBreathingGame()
    {
        if (CheckForOpenScreens() == false)
        {
            CloseOpenScreens();
            SwitchState(UIState.BreathingGame);
        }
    }

    public void DisplayPauseScreen(InputAction.CallbackContext context)
    {
        DisplayPauseScreen();
    }

    public void DisplayPauseScreen()
    {
        _previousMode = InputManager.Instance.CurrentMode;
        Debug.Log("Pause Button Pressed");
        if (CheckForOpenScreens() == false)
        {
            CloseOpenScreens();
            SwitchState(UIState.Pause);
        }
    }

    public void CloseOpenScreens()
    {
        _startScreen.SetActive(false);
        _pauseScreen.SetActive(false);
        _controlsScreen.SetActive(false);
        _maxStressScreen.SetActive(false);

        if (_storedUIState != UIState.Default)
        {
            SwitchState(_storedUIState);
            _storedUIState = UIState.Default;
        }
    }

    public void CloseAllScreens()
    {
        _startScreen.SetActive(false);
        _pauseScreen.SetActive(false);
        _controlsScreen.SetActive(false);
        _maxStressScreen.SetActive(false);
        _breathingGameScreen.SetActive(false);
    }

    public void DisplayControlMethodScreen()
    {
        CloseOpenScreens();
        SwitchState(UIState.ControlMethodSelection);
    }

    public void DisplayCreditsScreen()
    {
        CloseOpenScreens();
        SwitchState(UIState.Credits);
    }

    private bool CheckForOpenScreens()
    {
        if (_startScreen.activeSelf == true || _pauseScreen.activeSelf == true || _controlsScreen.activeSelf == true)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    public void ResumeGame()
    {
        //DisableMouse();
        CloseOpenScreens();
        Unpause();
        

    }

    public void LoadMainMenu()
    {
        SceneManager.LoadScene(_mainMenuSceneName);
    }

    private void OnMaxStressReached()
    {
        // If already showing a blocking screen, ignore.
        if (_currentState == UIState.MaxStress) return;

        OpenMaxStressScreen();
    }

    private void OpenMaxStressScreen()
    {
        CloseOpenScreens();
        _currentState = UIState.MaxStress;
        SwitchState(_currentState);
        EventSystem.current.SetSelectedGameObject(_defaultButtonMaxStress);
    }

    private void SetupNavigationForWebGL()
    {
        // This is required to rectify a bug in WebGL deployments where up and down does not work on GUI screens
        // Note: Not currently working in this build.  Believe because we are still using old input.  Further research required.
        InputBinding binding = new InputBinding()
        {
            path = "<Gamepad>/leftStick",
            processors = "webglnavigation"
        };

        //defaultNavigateInputActionReference.action.AddBinding(binding);
    }

}
